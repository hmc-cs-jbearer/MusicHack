{
  "rules": {
    ".read": "true",
    ".write": "true"
  }
}

/*
{
    "rules": {
        
        //".read" : true,
        //".write" : true,
        
        "networks": {
          
          // Only logged in users can see networks
          ".read" : "auth != null",
          
          // The networks key itself is static, only specific netwoks can be written if the user has the right permissions
          //".write" : false,
          
          "$network" : {
            
            // A user must be a member of a network to read
            ".read" : "data.child('users').hasChild(auth.uid)",
            
            // A user must be an admin of a network to write, except where explicity overridden
            // EDIT: for now, new users can add themselves without admin's approval.  We should change this feature.
            //".write" : "!data.hasChild('admins') ||
            //  (data.child('admins').hasChild(auth.uid))",
                        
              
            // Network doesn't exist, and input has admins, or network does exist and input has users 
            ".validate" : 
              "(!data.exists() && newData.hasChild('admins')) ||
              (data.exists() && newData.hasChild('users'))",
              
              "users" : {
                "$user" : {
                  // A user can edit their own data
                  ".write" : "$user == auth.uid || 
                    // An admin can add a new user
                    (!data.exists()) ||
                    // An admin can remove a user
                    (!newData.exists())"
                }
              },
              
              "admins" : {
                "$admin" : {
                   // An admin can edit their own data
                  ".write" : "$admin == auth.uid || 
                    // An admin can add a new admin
                    (!data.exists())"
                }
              },
              
              "queue" : {
                // Any user can edit the queue
                ".write" : "data.parent().child('users').hasChild(auth.uid)",
                
                "front" : {
                  // Front must point to a song in the queue 
                  ".validate" : "newData.parent().hasChild(newData.val())"
                },
                
                "back" : {
                  // Back must point to a song in the queue, and the back song can have no next song
                  ".validate" : "newData.parent().hasChild(newData.val()) && !newData.parent().child(newData.val()).hasChild('next')"
                },
                
                "$song_id" : {
                  ".validate" : "newData.hasChild('data') && newData.hasChild('requester')",
                  
                  "data" : {
                    ".validate" : "newData.hasChild('name') && newData.hasChild('artist_name') && newData.hasChild('album_name') && newData.hasChild('image_url')"
                  },
                  
                  "requester" : {
                    // The requester of the song must be the ID of a user in the network
                    ".validate" : "root.child('networks/$network/users').hasChild(newData.val())"
                  },
                  
                  "next" : {
                    // Net must point to a song in the queue
                    ".validate": "newData.parent().parent().hasChild(newData.val())"
                  }
                  
                }
              }
          }
        },
        
        "users": {
          ".write": "auth != null",
          ".validate" : true,
          ".read" : true,
          
          "$user" : {
            ".read" : "auth.uid == $user",
            ".write" : "auth.uid == $user",
            ".validate" : "newData.hasChildren(['networks', 'name', 'username']) && 
              newData.child('name').isString() && newData.child('username').isString()",
              
            "networks" : {
              "$network" : {
                ".validate" : "newData.hasChild('coins') &&
                  newData.child('coins').isNumber()"
              }
            }
           
          }
          
        } 
        
    }
}
*/